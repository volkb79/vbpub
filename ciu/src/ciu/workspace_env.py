#!/usr/bin/env python3
"""
Workspace environment loader for CIU.

This module reads .env.ciu files generated by ciu --generate-env
and exposes the values as process environment variables.
"""

from __future__ import annotations

import hashlib
import os
import shlex
import shutil
import socket
import subprocess
import sys
import urllib.error
import urllib.request
from pathlib import Path
from typing import Dict, Iterable, Optional

import re

STANDALONE_ROOT_PATTERN = re.compile(r"^\s*standalone_root\s*=\s*true\s*$", re.IGNORECASE)


ENV_FILE_NAME = ".env.ciu"


class WorkspaceEnvError(ValueError):
    """Raised when workspace environment file is missing or invalid."""


def find_workspace_env(start_dir: Path) -> Path:
    """Find .env.ciu by walking up from start_dir.

    Priority:
    1. REPO_ROOT environment variable (if set)
    2. Walk up directory tree from start_dir
    """
    repo_root = os.environ.get("REPO_ROOT")
    if repo_root:
        candidate = Path(repo_root).resolve() / ENV_FILE_NAME
        if candidate.exists():
            return candidate

    current = start_dir.resolve()
    while True:
        candidate = current / ENV_FILE_NAME
        if candidate.exists():
            return candidate
        if current == current.parent:
            break
        current = current.parent

    raise WorkspaceEnvError(
        f"Workspace environment file {ENV_FILE_NAME} not found. "
        "Run: ciu --generate-env (or ciu-deploy --generate-env)."
    )


def parse_workspace_env(path: Path) -> Dict[str, str]:
    """Parse .env.ciu into a dict of key/value pairs."""
    values: Dict[str, str] = {}

    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("export "):
            line = line[len("export ") :].strip()

        lexer = shlex.shlex(line, posix=True)
        lexer.whitespace_split = True
        lexer.commenters = "#"
        tokens = list(lexer)
        if not tokens:
            continue
        if len(tokens) != 1 or "=" not in tokens[0]:
            raise WorkspaceEnvError(
                f"Invalid {ENV_FILE_NAME} entry: {raw_line!r}"
            )

        key, value = tokens[0].split("=", 1)
        key = key.strip()
        if not key:
            raise WorkspaceEnvError(
                f"Invalid {ENV_FILE_NAME} entry (empty key): {raw_line!r}"
            )
        values[key] = value

    return values


def load_workspace_env(start_dir: Path, override: bool = False) -> Dict[str, str]:
    """Load .env.ciu and populate os.environ.

    Args:
        start_dir: Directory to begin searching for .env.ciu
        override: If True, overwrite existing os.environ values

    Returns:
        Dict of loaded values (from file)
    """
    env_path = find_workspace_env(start_dir)
    values = parse_workspace_env(env_path)

    for key, value in values.items():
        if override or key not in os.environ:
            os.environ[key] = value

    return values


def ensure_workspace_env(required_keys: Iterable[str]) -> None:
    """Ensure required environment variables are present.

    Raises WorkspaceEnvError if any are missing or empty.
    """
    missing = [key for key in required_keys if not os.environ.get(key)]
    if missing:
        missing_str = ", ".join(missing)
        raise WorkspaceEnvError(
            "Missing required workspace environment variables: "
            f"{missing_str}. "
            "Run: ciu --generate-env and source .env.ciu."
        )


def detect_standalone_root(start_dir: Path) -> Optional[Path]:
    """Detect a standalone CIU root based on ciu-global.defaults.toml.j2.

    Returns the nearest parent directory whose ciu-global.defaults.toml.j2
    contains 'standalone_root = true'.
    """
    current = start_dir.resolve()
    while True:
        candidate = current / "ciu-global.defaults.toml.j2"
        if candidate.exists():
            try:
                content = candidate.read_text(encoding="utf-8")
            except OSError:
                content = ""
            if STANDALONE_ROOT_PATTERN.search(content):
                return current
        if current == current.parent:
            break
        current = current.parent
    return None


def _detect_env_type() -> Dict[str, str]:
    env_type = os.environ.get("ENV_TYPE")
    if not env_type:
        if os.environ.get("GITHUB_ACTIONS"):
            env_type = "github-actions"
        elif os.environ.get("REMOTE_CONTAINERS") or os.environ.get("WORKSPACE_DIR") or Path("/.dockerenv").exists():
            env_type = "devcontainer"
        else:
            env_type = "bare-metal"

    return {
        "ENV_TYPE": env_type,
        "IS_DEVCONTAINER": "1" if env_type == "devcontainer" else "0",
        "IS_GITHUB_ACTIONS": "1" if env_type == "github-actions" else "0",
        "IS_BARE_METAL": "1" if env_type == "bare-metal" else "0",
    }


def _detect_public_fqdn(repo_root: Path, require_fqdn: bool) -> Dict[str, str]:
    public_fqdn = os.environ.get("PUBLIC_FQDN", "")
    public_ip = os.environ.get("PUBLIC_IP", "")

    if not public_fqdn:
        ciu_global = repo_root / "ciu-global.toml"
        if ciu_global.exists():
            try:
                import tomllib

                with ciu_global.open("rb") as f:
                    config = tomllib.load(f)
                public_fqdn = config.get("infrastructure", {}).get("public_fqdn", "")
            except Exception:
                public_fqdn = ""

    if not public_ip:
        try:
            with urllib.request.urlopen("https://api.ipify.org", timeout=10) as resp:
                public_ip = resp.read().decode("utf-8").strip()
        except (urllib.error.URLError, TimeoutError):
            public_ip = ""

    if not public_fqdn and public_ip:
        try:
            public_fqdn = socket.gethostbyaddr(public_ip)[0]
        except (socket.herror, socket.gaierror):
            public_fqdn = ""

    if not public_fqdn:
        if require_fqdn:
            raise WorkspaceEnvError("Failed to detect PUBLIC_FQDN. Set PUBLIC_FQDN in the environment.")
        public_fqdn = public_ip or "localhost"

    return {
        "PUBLIC_IP": public_ip,
        "PUBLIC_FQDN": public_fqdn,
        "PUBLIC_TLS_CRT_PEM": f"/etc/letsencrypt/live/{public_fqdn}/fullchain.pem",
        "PUBLIC_TLS_KEY_PEM": f"/etc/letsencrypt/live/{public_fqdn}/privkey.pem",
    }


def _detect_docker_gid() -> str:
    docker_gid = os.environ.get("DOCKER_GID", "")
    if docker_gid:
        return docker_gid

    for socket_path in ("/var/run/docker-host.sock", "/var/run/docker.sock"):
        if Path(socket_path).exists():
            return str(Path(socket_path).stat().st_gid)

    try:
        import grp

        return str(grp.getgrnam("docker").gr_gid)
    except KeyError:
        raise WorkspaceEnvError("DOCKER_GID not found. Ensure docker group exists or set DOCKER_GID.")


def _detect_physical_repo_root(repo_root: Path) -> Path:
    physical_root = os.environ.get("PHYSICAL_REPO_ROOT")
    if physical_root:
        return Path(physical_root).resolve()

    try:
        result = subprocess.run(
            ["docker", "ps", "--format", "{{.Label \"devcontainer.local_folder\"}}"],
            capture_output=True,
            text=True,
            check=False,
        )
        for line in result.stdout.splitlines():
            candidate = line.strip()
            if candidate:
                return Path(candidate).resolve()
    except FileNotFoundError:
        pass

    return repo_root.resolve()


def _compute_network_name(physical_root: Path) -> Dict[str, str]:
    repo_name = physical_root.name.lower()
    instance_id = hashlib.sha256(str(physical_root).encode("utf-8")).hexdigest()[:6]
    network_name = f"{repo_name}-{instance_id}-network"
    return {
        "REPO_NAME": repo_name,
        "INSTANCE_ID": instance_id,
        "DOCKER_NETWORK_INTERNAL": os.environ.get("DOCKER_NETWORK_INTERNAL", network_name),
    }


def generate_ciu_env(repo_root: Path, output_path: Optional[Path] = None) -> Path:
    """Generate .env.ciu with autodetected values.

    Returns the path to the generated file.
    """
    repo_root = repo_root.resolve()
    output_path = output_path or repo_root / ENV_FILE_NAME

    env_flags = _detect_env_type()
    docker_gid = _detect_docker_gid()
    physical_root = _detect_physical_repo_root(repo_root)
    network_values = _compute_network_name(physical_root)
    public_values = _detect_public_fqdn(repo_root, require_fqdn=False)

    user_name = os.environ.get("USER_NAME", os.environ.get("USER", ""))
    user_uid = os.environ.get("USER_UID", str(os.getuid()))
    user_gid = os.environ.get("USER_GID", str(os.getgid()))
    docker_uid = os.environ.get("DOCKER_UID", user_uid)

    container_uid = os.environ.get("CONTAINER_UID", user_uid)
    container_gid = os.environ.get("CONTAINER_GID", docker_gid)

    python_exec = os.environ.get("PYTHON_EXECUTABLE", sys.executable)
    pip_exec = os.environ.get("PIP_EXECUTABLE") or shutil.which("pip") or ""

    values = {
        **env_flags,
        "USER_NAME": user_name,
        "USER_UID": user_uid,
        "USER_GID": user_gid,
        "DOCKER_UID": docker_uid,
        "CONTAINER_UID": container_uid,
        "CONTAINER_GID": container_gid,
        "DOCKER_GID": docker_gid,
        "REPO_ROOT": str(repo_root),
        "PHYSICAL_REPO_ROOT": str(physical_root),
        **network_values,
        **public_values,
        "PYTHON_EXECUTABLE": python_exec,
        "PIP_EXECUTABLE": pip_exec,
    }

    lines = [
        "# CIU Workspace Environment (Auto-generated)",
        "# Do not edit manually - regenerated by ciu --generate-env",
    ]
    for key, value in values.items():
        lines.append(f"export {key}=\"{value}\"")

    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return output_path


def update_cert_permissions(repo_root: Path, public_fqdn: Optional[str] = None) -> None:
    """Run setup-letsencrypt-permissions.sh (requires root)."""
    if os.geteuid() != 0:
        raise WorkspaceEnvError(
            "--update-cert-permission requires root. "
            "Run: sudo ciu --update-cert-permission"
        )

    script_path = repo_root / "scripts" / "setup-letsencrypt-permissions.sh"
    if not script_path.exists():
        raise WorkspaceEnvError(
            f"Certificate permission script not found: {script_path}"
        )

    args = ["bash", str(script_path)]
    if public_fqdn:
        args.append(public_fqdn)

    subprocess.run(args, check=True)
