#!/bin/bash
#
# Git Credential Helper for GitHub Apps
# This script provides GitHub App tokens to Git for authentication
#

set -e

# Source the GitHub App configuration from multiple possible locations
for config_file in "$HOME/.zshrc" "$HOME/.bashrc" "$HOME/.profile"; do
    if [ -f "$config_file" ]; then
        eval "$(grep '^export.*GITHUB_APP' "$config_file" 2>/dev/null || true)"
        eval "$(grep '^export.*WRITEABLE_APP' "$config_file" 2>/dev/null || true)"
    fi
done

# Configuration with fallbacks
GITHUB_APP_ID="${GITHUB_APP_ID:-$WRITEABLE_APP_ID}"
GITHUB_APP_PRIVATE_KEY_PATH="${GITHUB_APP_PRIVATE_KEY_PATH:-$HOME/.ssh/github_app_key.pem}"
CACHE_FILE="$HOME/.cache/github-app-token"
CACHE_DIR="$(dirname "$CACHE_FILE")"

# Validate configuration
if [ -z "$GITHUB_APP_ID" ]; then
    log "ERROR: GITHUB_APP_ID not set. Please set WRITEABLE_APP_ID or GITHUB_APP_ID environment variable."
    exit 1
fi

# Ensure cache directory exists
mkdir -p "$CACHE_DIR"

# Function to log messages
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

# Function to generate JWT token
generate_jwt() {
    local app_id="$1"
    local private_key_path="$2"
    
    if [ ! -f "$private_key_path" ]; then
        log "ERROR: Private key not found: $private_key_path"
        return 1
    fi
    
    # JWT Header
    local header='{"alg":"RS256","typ":"JWT"}'
    local header_b64=$(echo -n "$header" | base64 -w 0 | tr -d '=' | tr '/+' '_-')
    
    # JWT Payload (valid for 10 minutes)
    local now=$(date +%s)
    local exp=$((now + 600))
    local payload="{\"iat\":$now,\"exp\":$exp,\"iss\":\"$app_id\"}"
    local payload_b64=$(echo -n "$payload" | base64 -w 0 | tr -d '=' | tr '/+' '_-')
    
    # Sign the JWT
    local signature_input="$header_b64.$payload_b64"
    local signature=$(echo -n "$signature_input" | openssl dgst -sha256 -sign "$private_key_path" | base64 -w 0 | tr -d '=' | tr '/+' '_-')
    
    echo "$header_b64.$payload_b64.$signature"
}

# Function to get installation token
get_installation_token() {
    local jwt_token="$1"
    
    # Get installation ID using the same logic as github_app_sync.sh
    log "INFO: Auto-discovering Installation ID..."
    local response=$(curl -s -w "\n%{http_code}" \
        -H "Authorization: Bearer $jwt_token" \
        -H "Accept: application/vnd.github+json" \
        -H "User-Agent: Git-Credential-GitHub-App/1.0" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        "https://api.github.com/app/installations")
    
    # Split response: body (all lines except last) + HTTP code (last line)
    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | head -n -1)
    
    if [[ "$http_code" != "200" ]]; then
        log "ERROR: Failed to get installations (HTTP $http_code)"
        log "ERROR: Response: $body"
        return 1
    fi
    
    # Extract first installation ID from JSON array using jq
    local installation_id=$(echo "$body" | jq -r '.[0].id // empty')
    
    if [ -z "$installation_id" ]; then
        log "ERROR: No installations found for GitHub App"
        return 1
    fi
    
    log "INFO: Using Installation ID: $installation_id"
    
    # Get installation token
    local token_response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Authorization: Bearer $jwt_token" \
        -H "Accept: application/vnd.github+json" \
        -H "User-Agent: Git-Credential-GitHub-App/1.0" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        "https://api.github.com/app/installations/$installation_id/access_tokens")
    
    # Split response
    local token_http_code=$(echo "$token_response" | tail -n1)
    local token_body=$(echo "$token_response" | head -n -1)
    
    if [[ "$token_http_code" != "201" ]]; then
        log "ERROR: Failed to get installation token (HTTP $token_http_code)"
        log "ERROR: Response: $token_body"
        return 1
    fi
    
    local token=$(echo "$token_body" | jq -r '.token // empty')
    local expires_at=$(echo "$token_body" | jq -r '.expires_at // empty')
    
    if [ -z "$token" ]; then
        log "ERROR: No token in response"
        return 1
    fi
    
    # Cache the token with expiration
    echo "$token|$expires_at" > "$CACHE_FILE"
    log "INFO: New GitHub App token cached (expires: $expires_at)"
    
    echo "$token"
}

# Function to get cached token if still valid
get_cached_token() {
    if [ ! -f "$CACHE_FILE" ]; then
        return 1
    fi
    
    local cached_data=$(cat "$CACHE_FILE")
    local cached_token=$(echo "$cached_data" | cut -d'|' -f1)
    local expires_at=$(echo "$cached_data" | cut -d'|' -f2)
    
    if [ -z "$cached_token" ] || [ -z "$expires_at" ]; then
        return 1
    fi
    
    # Check if token is still valid (with 5 minute buffer)
    local expires_timestamp=$(date -d "$expires_at" +%s 2>/dev/null || echo 0)
    local current_timestamp=$(date +%s)
    local buffer_seconds=300  # 5 minutes
    
    if [ $expires_timestamp -gt $((current_timestamp + buffer_seconds)) ]; then
        echo "$cached_token"
        return 0
    fi
    
    return 1
}

# Function to get GitHub App token
get_github_app_token() {
    # Try cached token first
    if token=$(get_cached_token); then
        log "INFO: Using cached GitHub App token"
        echo "$token"
        return 0
    fi
    
    # Generate new token
    log "INFO: Generating new GitHub App token"
    
    if [ -z "$GITHUB_APP_ID" ]; then
        log "ERROR: GITHUB_APP_ID not set"
        return 1
    fi
    
    local jwt_token=$(generate_jwt "$GITHUB_APP_ID" "$GITHUB_APP_PRIVATE_KEY_PATH")
    if [ -z "$jwt_token" ]; then
        log "ERROR: Failed to generate JWT"
        return 1
    fi
    
    get_installation_token "$jwt_token"
}

# Main credential helper logic
case "$1" in
    get)
        # Read credential request from stdin
        while IFS= read -r line; do
            case "$line" in
                protocol=*)
                    protocol="${line#protocol=}"
                    ;;
                host=*)
                    host="${line#host=}"
                    ;;
                path=*)
                    path="${line#path=}"
                    ;;
                "")
                    break
                    ;;
            esac
        done
        
        # Only handle GitHub requests
        if [ "$protocol" = "https" ] && [ "$host" = "github.com" ]; then
            token=$(get_github_app_token)
            if [ -n "$token" ]; then
                echo "protocol=$protocol"
                echo "host=$host"
                echo "username=x-access-token"
                echo "password=$token"
            else
                log "ERROR: Failed to get GitHub App token"
                exit 1
            fi
        fi
        ;;
    store)
        # We don't need to store credentials (tokens are ephemeral)
        ;;
    erase)
        # Clear cached token
        rm -f "$CACHE_FILE"
        log "INFO: GitHub App token cache cleared"
        ;;
    *)
        log "Usage: $0 {get|store|erase}"
        exit 1
        ;;
esac