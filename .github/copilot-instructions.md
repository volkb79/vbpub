# .github/copilot-instructions.md
> Purpose: Technical guidelines for AI-assisted development
> Priority: Infrastructure consistency > convenience

COPILOT_INSTRUCTIONS_VERSION: 2025-10-01 v4
COPILOT_INSTRUCTIONS_AGENTS_REF: AGENTS.md

## docker compose and .env Standards
- always use helper script 'compose-init-up.py' instead of 'docker compose up' 
  - will pre-process the env file before starting docker compose
  - use defined variables for control flow of the script 
  - use the pre-compose hook for custom initialization steps, e.g. getting dynamic user input like ephemeral secrets, dynamic generation of config files, variable substitution, etc.
  - how to verify: '.env.active' is created, check verbose output
  - NOTE: The single source of truth for the compose-init helper is `vbpub/scripts/docker/compose-init-up.py`. 
    Symlink to that script to generate `.env.active` and start services. Do not use copies. 
- use only modern 'docker compose', no 'docker-compose'
- yml    
  - modern syntax only, no 'version:' tag in file
  - externalize all values to .env file
  - only bind mounts based on env var with schema '<service>_HOSTDIR_<volname>' into local directories with schema './vol-<volname>', have 'vol-*/' in '.gitignore'
  - externally always expose HTTPS instead of HTTP, assume readable certs defined by PUBLIC_TLS_KEY_PEM in '/etc/letsencrypt/live/{PUBLIC_FQDN}/privkey.pem' (legacy TLS_KEY_PEM/TLS_CRT_PEM are still supported for now)
  - do not set 'CONTAINER_NAME'
  - do not define variable defaults, rely on .env file and 'compose-init-up.py' to detect missing variables
  - ensure labels are set for project, environment, component

### service specifics
- postgres: always setup with superuser 'POSTGRES_{USER|PASSWORD|DB}'
  - create credentials per service 'POSTGRES_<SERVICE>_{USER|PASSWORD|DB}'

### .env file
- only use '.env.sample' as template, keep updated during refactoring and development
- use environment vars and command substitution if needed to keep DRY and single point of truth
- generated 'env.active' should contain as few changes as possible to 'env.sample'
 - mandatory variables: PUBLIC_FQDN, PUBLIC_TLS_KEY_PEM, PUBLIC_TLS_CRT_PEM, LABEL_ENV_TAG (formerly ENV_TAG), LABEL_PREFIX, LABEL_PROJECT_NAME, COMPINIT_COMPOSE_START_MODE, COMPINIT_RESET_BEFORE_START, COMPINIT_CHECK_IMAGE_ENABLED, COMPINIT_IMAGE_CHECK_CONTINUE_ON_ERROR, HEALTHCHECK_INTERVAL,HEALTHCHECK_TIMEOUT, HEALTHCHECK_RETRIES, HEALTHCHECK_START_PERIOD
- prefix variables per service with '<SERVICE>_' to avoid collisions

### secrets
- use xxx_TOKEN_INTERNAL for self-generated tokens (treated like passwords and autogenerated if empty)
- use xxx_TOKEN_EXTERNAL for tokens that must be provided by an external secret store or prompted interactively
- legacy: xxx_TOKEN is treated as external and will prompt if empty
- use xxx_PASSWORD to have it generated during 'compose-init-up.py'

- example snippets
``` bash
# --------- Control flow for compose-init-up -----------
COMPINIT_COMPOSE_START_MODE=abort-on-failure
COMPINIT_RESET_BEFORE_START=none  
COMPINIT_CHECK_IMAGE_ENABLED=false
COMPINIT_IMAGE_CHECK_CONTINUE_ON_ERROR=0
COMPINIT_MYREGISTRY_URL=https://RA-R2001.vxxu.de:5000/
COMPINIT_PRECOMPOSEHOOK=
COMPINIT_POSTCOMPOSEHOOK=
COMPINIT_DEPENDENCIES="../whisper-trans,/home/vb/repos/vbpro/oobabooga-llm"

# ---------- global project Infrastructure ---------------------
PUBLIC_FQDN=ra-r2001.vxxu.de
PUBLIC_TLS_KEY_PEM=/etc/letsencrypt/live/${PUBLIC_FQDN}/privkey.pem
PUBLIC_TLS_CRT_PEM=/etc/letsencrypt/live/${PUBLIC_FQDN}/fullchain.pem

# Project metadata
LABEL_ENV_TAG=dev  # dev|staging|prod
LABEL_PREFIX=volkb79.vxxu.de
LABEL_PROJECT_NAME=DST-DNS

# global env vars available to all services
# global variable names adhere to the pattern 'GLOBAL_<VARNAME>' and should be used in yml files to set a variable '<VARNAME>'
GLOBAL_DEMO_FLAG=true 

# Health monitoring
HEALTHCHECK_INTERVAL=10s
HEALTHCHECK_TIMEOUT=5s
HEALTHCHECK_RETRIES=3
HEALTHCHECK_START_PERIOD=30s

# ----------- Service-specific settings ---------------------
POSTGRES_USER=postgres
POSTGRES_PASSWORD=   # left empty to be dynamically generated
POSTGRES_DB=postgres
POSTGRES_API_USER=api
POSTGRES_API_DB=api
POSTGRES_API_PASSWORD=   # left empty to be dynamically generated

EXTSERVICE_API_TOKEN=  # left empty to be queried from user input

# -------- grouped bind volumes / host-dir definitions for all services at the end of the file -------------
# var name and directory name follow pattern: `{SERVICE}_HOSTDIR_{VOLUME}` â†’ `./vol-{service}-{volume}`
# Git exclusion: Add `vol-*/` to `.gitignore`
POSTGRES_HOSTDIR_DATA=./vol-postgres-data  
API_HOSTDIR_LOGS=./vol-api-logs
REDIS_HOSTDIR_DATA=./vol-redis-data


# ----------- User and Group IDs for file permissions ---------
# used for UID/GID the containers run as, to allow file access on host volumes
# The sample uses command substitution so the real numeric IDs are determined when
# compose-init-up.py creates the .env.active file and written to it. 
# If you prefer to hardcode values, replace the $(...) with explicit numbers.
UID=$(id -u)
GID=$(id -g)
```
NOTE: This file contains concise, machine-oriented rules. For extended developer/agent guidance (venv setup, VS Code, Poetry, CI), see `AGENTS.md` (human-facing, versioned).


```yaml
# common settings for all services, e.g. labels or global variables with '<<: *service-defaults'
x-defaults: &service-defaults  
  labels:
    - "project=${LABEL_PROJECT_NAME}"
    - "${LABEL_PREFIX}.environment=${LABEL_ENV_TAG}"
  user: "${UID:-0}:${GID:-0}"  # have services run as current user by default, fallback to root
  environment:
    - DEMO_FLAG=${GLOBAL_DEMO_FLAG}  # example global env var available to all services

# âœ… Modern syntax only
services:
  <<: *service-defaults
  api:
  # âŒ No version: tag
  # âŒ No container_name: override    
  # âœ… Volume patterns  
  volumes:
    - ${SERVICE_HOSTDIR_LOGS}:/app/logs  # container-specific dir
    - ${SERVICE_HOSTDIR_CACHE}:/tmp/cache # container-specific dir
  labels:
    - ${LABEL_PREFIX}.component=api  # apply custom labels including prefix
  
postgres:
  <<: *service-defaults
  environment:
    - POSTGRES_USER=${POSTGRES_USER}
    - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}  
    - POSTGRES_DB=${POSTGRES_DB}
    # Per-service users during init
    - POSTGRES_API_USER=${POSTGRES_API_USER}
    - POSTGRES_API_PASSWORD=${POSTGRES_API_PASSWORD}
    - POSTGRES_API_DB=${POSTGRES_API_DB}
  labels:
    - ${LABEL_PREFIX}.component=postgres  # apply custom labels including prefix
```


# Greenfield migration policy (agents)

This repository is treated as greenfield. Do NOT add compatibility code or
fallbacks that support legacy variable, function, or class names. When you
change configuration names or refactor behavior, perform a complete repository-wide replacement:

- Replace all occurrences of the old names with the new canonical names (search
  and replace across code, docs, and config and comments). 
- Do not write runtime fallbacks. Do not support old names anymore.
- Update the '.env.sample.toml' config file, README, developer docs, tests, and CI in the same change.
- Add tests (unit/integration) that assert the new canonical behavior and
  prevent regressions.
- If a migration script is needed, make it a one-time explicit script and
  document its purpose; do not leave migration shims in production code.

Agents and Copilot workflows should assume no production dependency on legacy
names and may safely remove or replace them as part of an atomic refactor.

## ðŸ’» Code Quality Standards

### Python Development
```python
# âœ… Always use virtualenv/poetry
# âœ… Verbose logging with context
logger.info("Database connection established", 
           host=db_host, port=db_port, user=db_user)

# âœ… Robust error handling  
try:
    result = await api_call()
    logger.info("API call successful", response_time=elapsed)
except Exception as e:
    logger.error("API call failed", error=str(e), endpoint=url)
    raise
```

### Logging Consistency 
- Format: `[INFO]`, `[WARN]`, `[ERROR]`, `[STEP]` (match `infra/start-init.py`)
- Context: Always log before/after significant operations
- Tracing: Include correlation IDs, request context

### Documentation Requirements
- Inline comments: Explain complex regex, algorithms, business logic
- Function docstrings: Document intent for testing/debugging
- Configuration: Document all environment variables with examples

## ðŸ›¡ï¸ Security & Operations

### Terminal Usage
- No sudo: Ask user to run privileged commands manually
- Non-blocking: Avoid not automatically terminating foreground processes
- File-based scripts: Complex commands â†’ script files (not compound CLI)

### Speech Input Processing (Project Context)
- Auto-correct: Fix common speech-to-text errors for tech terms
- Project vocabulary: DNS, Docker, compose, PostgreSQL, Redis, webhooks, ... use repo context

## ðŸ”„ Testing & Validation

### Required Validation Steps
```bash
# After any infrastructure changes:
# 0. Ensure a clean start by setting COMPINIT_RESET_BEFORE_START appropriately to delete state
1. ./compose-init-up.py  # will create new .env.active and start services
2. Check service health endpoints
3. Validate generated configs (webhook-hooks.yml, etc.)
4. Test SSL certificate mounting
5. Verify volume permissions and data persistence
```

### Environment Testing
- verbose output of found conditions and variables to allow debugging
- Check external service availability (e.g., database, cache) and authentication
- Validate read config files before deployment

